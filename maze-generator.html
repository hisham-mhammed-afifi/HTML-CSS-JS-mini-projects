<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Maze Generator & Solver</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Arial, sans-serif;
        background-color: #1a1a2e;
        color: #eee;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
      }

      h1 {
        margin-bottom: 20px;
        text-align: center;
        color: #f39c12;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .controls {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
        flex-wrap: wrap;
        justify-content: center;
      }

      button {
        background-color: #3498db;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s, transform 0.1s;
      }

      button:hover {
        background-color: #2980b9;
        transform: translateY(-2px);
      }

      button:active {
        transform: translateY(0);
      }

      select {
        padding: 10px;
        border-radius: 5px;
        background-color: #34495e;
        color: white;
        border: none;
        font-size: 16px;
        cursor: pointer;
      }

      .maze-container {
        background-color: #0f3460;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        position: relative;
      }

      #maze {
        display: grid;
        gap: 0;
        border: 2px solid #e94560;
      }

      .cell {
        width: 25px;
        height: 25px;
        background-color: #16213e;
        position: relative;
        transition: background-color 0.3s;
      }

      /* Wall styles */
      .wall-top {
        border-top: 2px solid #e94560;
      }

      .wall-right {
        border-right: 2px solid #e94560;
      }

      .wall-bottom {
        border-bottom: 2px solid #e94560;
      }

      .wall-left {
        border-left: 2px solid #e94560;
      }

      /* Special cell styles */
      .start {
        background-color: #2ecc71 !important;
      }

      .end {
        background-color: #e74c3c !important;
      }

      .player {
        background-color: #f39c12 !important;
        box-shadow: 0 0 10px rgba(243, 156, 18, 0.8);
      }

      .visited {
        background-color: #3498db !important;
        opacity: 0.5;
      }

      .path {
        background-color: #9b59b6 !important;
        animation: pulse 0.5s ease-in-out;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }

      /* Mobile controls */
      .mobile-controls {
        display: none;
        grid-template-columns: repeat(3, 60px);
        grid-template-rows: repeat(3, 60px);
        gap: 5px;
        margin-top: 20px;
        justify-content: center;
      }

      .arrow-btn {
        background-color: #34495e;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 30px;
        color: white;
        transition: background-color 0.2s;
      }

      .arrow-btn:hover {
        background-color: #2c3e50;
      }

      .arrow-btn:nth-child(2) {
        grid-column: 2;
      }
      .arrow-btn:nth-child(3) {
        grid-column: 1;
        grid-row: 2;
      }
      .arrow-btn:nth-child(4) {
        grid-column: 3;
        grid-row: 2;
      }
      .arrow-btn:nth-child(5) {
        grid-column: 2;
        grid-row: 3;
      }

      .win-message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #2ecc71;
        color: white;
        padding: 30px 50px;
        border-radius: 10px;
        font-size: 24px;
        text-align: center;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        display: none;
        animation: fadeIn 0.5s;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translate(-50%, -60%);
        }
        to {
          opacity: 1;
          transform: translate(-50%, -50%);
        }
      }

      /* Responsive styles */
      @media (max-width: 768px) {
        .mobile-controls {
          display: grid;
        }

        .cell {
          width: 15px;
          height: 15px;
        }

        h1 {
          font-size: 24px;
        }

        button,
        select {
          font-size: 14px;
          padding: 8px 16px;
        }
      }

      /* Loading animation */
      .solving {
        animation: solving 0.5s linear infinite;
      }

      @keyframes solving {
        0% {
          opacity: 0.3;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0.3;
        }
      }
    </style>
  </head>
  <body>
    <h1>üéÆ Maze Generator & Solver</h1>

    <div class="controls">
      <button id="newMazeBtn">New Maze</button>
      <button id="solveMazeBtn">Solve Maze</button>
      <button id="resetBtn">Reset Position</button>
      <select id="sizeSelect">
        <option value="10">10x10</option>
        <option value="15">15x15</option>
        <option value="20" selected>20x20</option>
        <option value="25">25x25</option>
      </select>
    </div>

    <div class="maze-container">
      <div id="maze"></div>
    </div>

    <div class="mobile-controls">
      <div></div>
      <button class="arrow-btn" data-direction="up">‚Üë</button>
      <button class="arrow-btn" data-direction="left">‚Üê</button>
      <div></div>
      <button class="arrow-btn" data-direction="right">‚Üí</button>
      <div></div>
      <button class="arrow-btn" data-direction="down">‚Üì</button>
    </div>

    <div class="win-message" id="winMessage">
      üéâ Congratulations! You've completed the maze! üéâ
    </div>

    <script>
      // Maze class to handle all maze operations
      class MazeGame {
        constructor(containerId) {
          this.container = document.getElementById(containerId);
          this.size = 20;
          this.grid = [];
          this.playerPos = { x: 0, y: 0 };
          this.startPos = { x: 0, y: 0 };
          this.endPos = { x: 0, y: 0 };
          this.solving = false;

          this.initializeEventListeners();
          this.generateMaze();
        }

        // Initialize all event listeners
        initializeEventListeners() {
          // Keyboard controls
          document.addEventListener("keydown", (e) => this.handleKeyPress(e));

          // Button controls
          document
            .getElementById("newMazeBtn")
            .addEventListener("click", () => this.generateMaze());
          document
            .getElementById("solveMazeBtn")
            .addEventListener("click", () => this.solveMaze());
          document
            .getElementById("resetBtn")
            .addEventListener("click", () => this.resetPlayerPosition());

          // Size selector
          document
            .getElementById("sizeSelect")
            .addEventListener("change", (e) => {
              this.size = parseInt(e.target.value);
              this.generateMaze();
            });

          // Mobile controls
          document.querySelectorAll(".arrow-btn").forEach((btn) => {
            btn.addEventListener("click", () => {
              const direction = btn.dataset.direction;
              this.movePlayer(direction);
            });
          });
        }

        // Generate a new maze using recursive backtracking
        generateMaze() {
          this.hideWinMessage();
          this.solving = false;

          // Initialize grid with all walls
          this.grid = Array(this.size)
            .fill(null)
            .map(() =>
              Array(this.size)
                .fill(null)
                .map(() => ({
                  visited: false,
                  walls: { top: true, right: true, bottom: true, left: true },
                }))
            );

          // Set start and end positions
          this.startPos = { x: 0, y: 0 };
          this.endPos = { x: this.size - 1, y: this.size - 1 };
          this.playerPos = { ...this.startPos };

          // Generate maze using recursive backtracking
          this.recursiveBacktrack(0, 0);

          // Render the maze
          this.renderMaze();
        }

        // Recursive backtracking algorithm for maze generation
        recursiveBacktrack(x, y) {
          this.grid[y][x].visited = true;

          // Get neighbors in random order
          const neighbors = this.getUnvisitedNeighbors(x, y);
          this.shuffleArray(neighbors);

          for (const neighbor of neighbors) {
            const { x: nx, y: ny } = neighbor;

            if (!this.grid[ny][nx].visited) {
              // Remove walls between current cell and neighbor
              this.removeWalls(x, y, nx, ny);

              // Recursively visit neighbor
              this.recursiveBacktrack(nx, ny);
            }
          }
        }

        // Get unvisited neighboring cells
        getUnvisitedNeighbors(x, y) {
          const neighbors = [];
          const directions = [
            { x: 0, y: -1 }, // up
            { x: 1, y: 0 }, // right
            { x: 0, y: 1 }, // down
            { x: -1, y: 0 }, // left
          ];

          for (const dir of directions) {
            const nx = x + dir.x;
            const ny = y + dir.y;

            if (nx >= 0 && nx < this.size && ny >= 0 && ny < this.size) {
              if (!this.grid[ny][nx].visited) {
                neighbors.push({ x: nx, y: ny });
              }
            }
          }

          return neighbors;
        }

        // Remove walls between two adjacent cells
        removeWalls(x1, y1, x2, y2) {
          const dx = x2 - x1;
          const dy = y2 - y1;

          if (dx === 1) {
            // Moving right
            this.grid[y1][x1].walls.right = false;
            this.grid[y2][x2].walls.left = false;
          } else if (dx === -1) {
            // Moving left
            this.grid[y1][x1].walls.left = false;
            this.grid[y2][x2].walls.right = false;
          } else if (dy === 1) {
            // Moving down
            this.grid[y1][x1].walls.bottom = false;
            this.grid[y2][x2].walls.top = false;
          } else if (dy === -1) {
            // Moving up
            this.grid[y1][x1].walls.top = false;
            this.grid[y2][x2].walls.bottom = false;
          }
        }

        // Fisher-Yates shuffle algorithm
        shuffleArray(array) {
          for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
          }
        }

        // Render the maze to the DOM
        renderMaze() {
          this.container.innerHTML = "";
          this.container.style.gridTemplateColumns = `repeat(${this.size}, 1fr)`;

          for (let y = 0; y < this.size; y++) {
            for (let x = 0; x < this.size; x++) {
              const cell = document.createElement("div");
              cell.className = "cell";
              cell.dataset.x = x;
              cell.dataset.y = y;

              // Add wall classes
              const walls = this.grid[y][x].walls;
              if (walls.top) cell.classList.add("wall-top");
              if (walls.right) cell.classList.add("wall-right");
              if (walls.bottom) cell.classList.add("wall-bottom");
              if (walls.left) cell.classList.add("wall-left");

              // Mark special cells
              if (x === this.startPos.x && y === this.startPos.y) {
                cell.classList.add("start");
              }
              if (x === this.endPos.x && y === this.endPos.y) {
                cell.classList.add("end");
              }
              if (x === this.playerPos.x && y === this.playerPos.y) {
                cell.classList.add("player");
              }

              this.container.appendChild(cell);
            }
          }
        }

        // Handle keyboard input
        handleKeyPress(e) {
          if (this.solving) return;

          switch (e.key) {
            case "ArrowUp":
              e.preventDefault();
              this.movePlayer("up");
              break;
            case "ArrowRight":
              e.preventDefault();
              this.movePlayer("right");
              break;
            case "ArrowDown":
              e.preventDefault();
              this.movePlayer("down");
              break;
            case "ArrowLeft":
              e.preventDefault();
              this.movePlayer("left");
              break;
          }
        }

        // Move the player in the specified direction
        movePlayer(direction) {
          if (this.solving) return;

          const { x, y } = this.playerPos;
          let newX = x;
          let newY = y;

          // Determine new position
          switch (direction) {
            case "up":
              if (!this.grid[y][x].walls.top) newY--;
              break;
            case "right":
              if (!this.grid[y][x].walls.right) newX++;
              break;
            case "down":
              if (!this.grid[y][x].walls.bottom) newY++;
              break;
            case "left":
              if (!this.grid[y][x].walls.left) newX--;
              break;
          }

          // Check if move is valid
          if (newX >= 0 && newX < this.size && newY >= 0 && newY < this.size) {
            // Update player position
            this.updatePlayerPosition(newX, newY);

            // Check for win condition
            if (newX === this.endPos.x && newY === this.endPos.y) {
              this.showWinMessage();
            }
          }
        }

        // Update player position in the grid
        updatePlayerPosition(newX, newY) {
          // Remove player class from old position
          const oldCell = this.container.querySelector(
            `[data-x="${this.playerPos.x}"][data-y="${this.playerPos.y}"]`
          );
          if (oldCell) oldCell.classList.remove("player");

          // Update position
          this.playerPos.x = newX;
          this.playerPos.y = newY;

          // Add player class to new position
          const newCell = this.container.querySelector(
            `[data-x="${newX}"][data-y="${newY}"]`
          );
          if (newCell) newCell.classList.add("player");
        }

        // Reset player to starting position
        resetPlayerPosition() {
          this.updatePlayerPosition(this.startPos.x, this.startPos.y);
          this.clearSolution();
        }

        // Clear solution visualization
        clearSolution() {
          document.querySelectorAll(".visited, .path").forEach((cell) => {
            cell.classList.remove("visited", "path");
          });
        }

        // Solve the maze using BFS (Breadth-First Search)
        async solveMaze() {
          if (this.solving) return;

          this.solving = true;
          this.clearSolution();

          // BFS setup
          const queue = [{ x: this.startPos.x, y: this.startPos.y, path: [] }];
          const visited = new Set();
          visited.add(`${this.startPos.x},${this.startPos.y}`);

          while (queue.length > 0) {
            const { x, y, path } = queue.shift();
            const newPath = [...path, { x, y }];

            // Visualize current position
            const cell = this.container.querySelector(
              `[data-x="${x}"][data-y="${y}"]`
            );
            if (cell && !(x === this.startPos.x && y === this.startPos.y)) {
              cell.classList.add("visited");
            }

            // Check if we reached the end
            if (x === this.endPos.x && y === this.endPos.y) {
              await this.visualizeSolution(newPath);
              this.solving = false;
              return;
            }

            // Add delay for visualization
            await this.delay(20);

            // Check all possible moves
            const moves = [
              { dx: 0, dy: -1, wall: "top" },
              { dx: 1, dy: 0, wall: "right" },
              { dx: 0, dy: 1, wall: "bottom" },
              { dx: -1, dy: 0, wall: "left" },
            ];

            for (const move of moves) {
              const newX = x + move.dx;
              const newY = y + move.dy;
              const key = `${newX},${newY}`;

              // Check if move is valid
              if (
                newX >= 0 &&
                newX < this.size &&
                newY >= 0 &&
                newY < this.size &&
                !visited.has(key) &&
                !this.grid[y][x].walls[move.wall]
              ) {
                visited.add(key);
                queue.push({ x: newX, y: newY, path: newPath });
              }
            }
          }

          this.solving = false;
        }

        // Visualize the solution path
        async visualizeSolution(path) {
          // Clear visited cells
          document.querySelectorAll(".visited").forEach((cell) => {
            cell.classList.remove("visited");
          });

          // Animate solution path
          for (const { x, y } of path) {
            const cell = this.container.querySelector(
              `[data-x="${x}"][data-y="${y}"]`
            );
            if (cell) {
              cell.classList.add("path");
              await this.delay(50);
            }
          }
        }

        // Utility function for delays
        delay(ms) {
          return new Promise((resolve) => setTimeout(resolve, ms));
        }

        // Show win message
        showWinMessage() {
          const winMessage = document.getElementById("winMessage");
          winMessage.style.display = "block";
          setTimeout(() => {
            winMessage.style.display = "none";
            this.generateMaze();
          }, 3000);
        }

        // Hide win message
        hideWinMessage() {
          document.getElementById("winMessage").style.display = "none";
        }
      }

      // Initialize the game when the DOM is loaded
      document.addEventListener("DOMContentLoaded", () => {
        const game = new MazeGame("maze");
      });
    </script>
  </body>
</html>
